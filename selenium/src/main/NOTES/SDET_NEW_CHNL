DAY 1
------------
LOCATORS
------------
id
name
link text - partial link text
class name
tag name




------------
CUSTOMIZED LOCATORS
______________

CSS SELECTOR
--------------
tag id
tag class
tag attribute
tag class and attribute

XPATH
---------
Absolute xpath
Relative xpath



CSS SELECTOR

tag id    -     tag#id    tag of element , id of element ( # )

tag class    --    tag.classname ( . )          locate group of element  as well single element

tag attribute   -    tag[attribute="value"]

tag class attribute -   tag.classname[attribute = "value"]    locate ( single element specific element )


-------------------------------------------------
css move in 1 direction

xpath move all direction  with -- xpath Axes
--------------------------------------------------
xpath axes
-----------
self
parent
child
ancestor
descendent
following
preceding
following - sibling
preceding - sibling

---------------------------------------------------------------------------------------------------------

## **🔥 XPath Axes – Easy Reference for SDET & Interviews**

### **1. `child::`**

* **Meaning:** Selects **direct children** of the current node.
* **Syntax:**

  ```xpath
  //div[@id='container']/child::input
  ```
* **Shortcut:** `/input` (works the same without `child::`).
* **When to use:** When you know the immediate child structure.
* **Tip:** Won’t go deeper than one level.

---

### **2. `parent::`**

* **Meaning:** Selects the **parent** of the current node.
* **Syntax:**

  ```xpath
  //input[@id='username']/parent::div
  ```
* **When to use:** If you have a child element but need to go **up** to find its parent container.
* **Shortcut:** `/..` (dot-dot means "go to parent").

---

### **3. `ancestor::`**

* **Meaning:** Selects **all parent levels** up to the root (grandparent, great-grandparent, etc.).
* **Syntax:**

  ```xpath
  //input[@id='username']/ancestor::form
  ```
* **When to use:** When you need to climb up the DOM tree to a bigger container.
* **Pro tip:** Great for targeting whole forms or sections when starting from a known element.

---

### **4. `descendant::`**

* **Meaning:** Selects **all levels of children** (child, grandchild, great-grandchild).
* **Syntax:**

  ```xpath
  //div[@id='menu']/descendant::a
  ```
* **Shortcut:** `//a` (double slash already means any level down).
* **When to use:** When you want any nested elements under a container.

---

### **5. `following::`**

* **Meaning:** Selects everything **below and after** the current node in the DOM (not just siblings).
* **Syntax:**

  ```xpath
  //h2[text()='Login']/following::input
  ```
* **When to use:** To get any elements that appear **later** in the page after a known element.

---

### **6. `preceding::`**

* **Meaning:** Selects everything **above and before** the current node in the DOM.
* **Syntax:**

  ```xpath
  //input[@id='password']/preceding::label
  ```
* **When to use:** When you know a field but need to target something that comes before it.

---

### **7. `following-sibling::`**

* **Meaning:** Selects siblings **on the same level** **after** the current element.
* **Syntax:**

  ```xpath
  //label[text()='Username']/following-sibling::input
  ```
* **When to use:** When elements are horizontally aligned in the HTML (same parent).

---

### **8. `preceding-sibling::`**

* **Meaning:** Selects siblings **before** the current element.
* **Syntax:**

  ```xpath
  //input[@id='email']/preceding-sibling::label
  ```
* **When to use:** Useful for form labels located before input fields.

---

### **9. `self::`**

* **Meaning:** Selects the **current node itself**.
* **Syntax:**

  ```xpath
  //input[@id='username']/self::input
  ```
* **When to use:** Rare in practice, but useful when applying conditions on the current element.

---

### **10. `attribute::`**

* **Meaning:** Selects an attribute of a node.
* **Syntax:**

  ```xpath
  //input[@id='username']/attribute::type
  ```
* **Shortcut:** `@type`
* **When to use:** Not often in Selenium, but useful in XML parsing.

---

## **💡 Quick Interview Table:**

| Axis Name             | Moves To                        | Shortcut Available? | Practical Use Case               |
| --------------------- | ------------------------------- | ------------------- | -------------------------------- |
| `child::`             | Direct child elements           | `/`                 | Get inputs inside a div          |
| `parent::`            | Immediate parent                | `/..`               | From field → go to container div |
| `ancestor::`          | All parent levels               | ❌                   | From input → get full form       |
| `descendant::`        | All child levels                | `//`                | Get all nested links in nav      |
| `following::`         | All elements after in DOM       | ❌                   | From heading → get next inputs   |
| `preceding::`         | All elements before in DOM      | ❌                   | From input → find earlier labels |
| `following-sibling::` | Siblings after current element  | ❌                   | Get textboxes after labels       |
| `preceding-sibling::` | Siblings before current element | ❌                   | Get labels before inputs         |
| `self::`              | Current node                    | ❌                   | Rare - for conditions            |
| `attribute::`         | Attribute value                 | `@attrName`         | Get type/id values               |

---

✅ **Memory Trick:**
Think of the DOM as a **family tree**:

* **child**, **parent**, **ancestor**, **descendant** → family relations.
* **following**, **preceding** → time travel up/down the HTML.
* **siblings** → elements with the same parent.
* **self** → “me”.
* **attribute** → “my property”.

---------------------------------------------------------------------------------------------------------------------------------------------

selenium methods
======================

1 get methods
2 conditional methods
3 browser methods
4 navigational methodds
5 wait methods


1 get methods we can access these methods through webdriver instance
-----------------------------------------------------------------------

get(url) opens the url on the browser

getTitle() returns title of the page

getCurrentUrl() retuns URL of the page

getPageSource()- returns source code of the page

getWindowHandle() returns ID of the single Browser window    id should be dynamic : every time it will change

getWindowHandles() retuns ID's of the multiple browser window      get id of multiple windows

    set collection not allow duplicates  ---- > mostly we can use set in get the id of multiple win because every thing have unique values
    list collection allow duplicates

-------------------------------------------------------------------------------------------------------------------------------

Conditional methods () -------> access these commands through Webelement

returns boolean value (true / false)

isDisplayed()  ------> element is visible or not ----- >check display status

isEnable() ---------> check enable/disable status of the element / operational element

isSelected() ------>  check element is selected or not (radio button , check box , drop down also)

--------------------------------------------------------------------------------------------------------------------------

browser method
-------------------

close()  = close single browser  ( parent win first close )
quit() = close multiple browser

----------------------------------------------------------------------------------------------------------------------

wait commands
----------------

synchronize  problem  ---

thread.sleep()
1 implicit wait
2  explicit wait / fluent wait

noSuchElementException -- Element is not present on the page.Synchronization.
ElementNotFoundException  -- Locator is in correct

sleep() --- java based
----------

Adv - easy to use

dis - IF TIME IS NOT SUFFICIENT THEN YOU WILL GET EXCEPTION ,
       it will wait for max time out this will reduce performance script
       multiple

implicitwait()
-------------------
driver.manage().timeout().implicitWait()timeDuration.of.Seconds(10));

ADV: single time , IT WILL NOT WAIT TILL MAX TIME IF THE ELEMENT IS AVAILABLE , applicable for all element ,

DIS : IF TIME IS NOT SUFFICIENT THEN YOU WILL GET EXCEPTION

ExplicitWait()
-------------------

 Declaration = WebDriverWait wait = new WebDriverWait(driver,Duration.ofSeconds(4));   //declaration

 Use =     WebElement usertxt = wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("//input[@placeholder='Username']"))); // use the declaration

           usertxt.sendKeys("Admin");


==================================================================================================================

Gotcha — you basically want the **full list of `ExpectedConditions` in Selenium**, not just the common ones.

Here’s the **official breakdown** (based on Selenium 4.x API) — these are all the static helper methods from `org.openqa.selenium.support.ui.ExpectedConditions` you can use with `WebDriverWait`.

---

## **📜 Full ExpectedConditions List in Selenium**

(With short descriptions so you know when to use each)

---

### **Element Presence & Visibility**

| Method                                                               | What It Does                                                       |
| -------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `presenceOfElementLocated(By locator)`                               | Waits until the element is in the DOM (visibility not guaranteed). |
| `presenceOfAllElementsLocatedBy(By locator)`                         | Waits until *all* elements matching locator are in the DOM.        |
| `visibilityOf(WebElement element)`                                   | Waits until the given element is visible.                          |
| `visibilityOfElementLocated(By locator)`                             | Waits until the element located by locator is visible.             |
| `visibilityOfAllElements(List<WebElement> elements)`                 | Waits until all given elements are visible.                        |
| `visibilityOfAllElementsLocatedBy(By locator)`                       | Waits until all located elements are visible.                      |
| `visibilityOfAllElementsLocatedBy(By locator, String text)` *(Rare)* | Same as above but matching text.                                   |

---

### **Clickability**

| Method                                     | What It Does                                                  |
| ------------------------------------------ | ------------------------------------------------------------- |
| `elementToBeClickable(WebElement element)` | Waits until element is visible & enabled so you can click it. |
| `elementToBeClickable(By locator)`         | Same as above but locator-based.                              |

---

### **Invisibility & Staleness**

| Method                                                 | What It Does                                              |
| ------------------------------------------------------ | --------------------------------------------------------- |
| `invisibilityOf(WebElement element)`                   | Waits until given element is not visible (or not in DOM). |
| `invisibilityOfElementLocated(By locator)`             | Waits until located element is invisible.                 |
| `invisibilityOfAllElements(List<WebElement> elements)` | Waits until all elements are invisible.                   |
| `stalenessOf(WebElement element)`                      | Waits until given element is detached from DOM.           |

---

### **Text-Related**

| Method                                                           | What It Does                                                    |
| ---------------------------------------------------------------- | --------------------------------------------------------------- |
| `textToBePresentInElement(WebElement element, String text)`      | Waits until given element contains text.                        |
| `textToBePresentInElementLocated(By locator, String text)`       | Same as above but locator-based.                                |
| `textToBePresentInElementValue(By locator, String text)`         | Waits until `<input>` or `<textarea>` contains the given value. |
| `textToBePresentInElementValue(WebElement element, String text)` | Same but WebElement-based.                                      |
| `textMatches(By locator, Pattern pattern)`                       | Waits until element text matches regex.                         |
| `textMatches(WebElement element, Pattern pattern)`               | Same but WebElement-based.                                      |

---

### **Attribute & Selection**

| Method                                                             | What It Does                                    |
| ------------------------------------------------------------------ | ----------------------------------------------- |
| `attributeToBe(WebElement element, String attr, String value)`     | Waits until element’s attribute equals value.   |
| `attributeToBe(By locator, String attr, String value)`             | Locator-based version.                          |
| `attributeContains(WebElement element, String attr, String value)` | Waits until attribute contains value.           |
| `attributeContains(By locator, String attr, String value)`         | Locator-based.                                  |
| `attributeToBeNotEmpty(WebElement element, String attr)`           | Waits until attribute is not empty.             |
| `attributeToBeNotEmpty(By locator, String attr)`                   | Locator-based.                                  |
| `elementSelectionStateToBe(WebElement element, boolean selected)`  | Waits until checkbox/radio has selection state. |
| `elementSelectionStateToBe(By locator, boolean selected)`          | Locator-based.                                  |
| `elementToBeSelected(WebElement element)`                          | Waits until element is selected.                |
| `elementToBeSelected(By locator)`                                  | Locator-based.                                  |

---

### **Frames**

| Method                                                     | What It Does                                 |
| ---------------------------------------------------------- | -------------------------------------------- |
| `frameToBeAvailableAndSwitchToIt(int index)`               | Waits for frame (by index) & switches to it. |
| `frameToBeAvailableAndSwitchToIt(String nameOrId)`         | Frame by name or id.                         |
| `frameToBeAvailableAndSwitchToIt(WebElement frameElement)` | Frame by WebElement.                         |
| `frameToBeAvailableAndSwitchToIt(By locator)`              | Frame by locator.                            |

---

### **Alerts**

| Method             | What It Does                         |
| ------------------ | ------------------------------------ |
| `alertIsPresent()` | Waits until an alert box is present. |

---

### **Number of Elements**

| Method                                                 | What It Does                                                 |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `numberOfElementsToBe(By locator, int number)`         | Waits until number of matching elements equals given number. |
| `numberOfElementsToBeLessThan(By locator, int number)` | Waits until count is less than number.                       |
| `numberOfElementsToBeMoreThan(By locator, int number)` | Waits until count is greater than number.                    |
| `numberOfWindowsToBe(int number)`                      | Waits until window/tab count equals number.                  |

---

### **Miscellaneous**

| Method                                                   | What It Does                                         |
| -------------------------------------------------------- | ---------------------------------------------------- |
| `titleIs(String title)`                                  | Waits until page title matches exactly.              |
| `titleContains(String title)`                            | Waits until page title contains text.                |
| `urlToBe(String url)`                                    | Waits until current URL matches exactly.             |
| `urlContains(String fraction)`                           | Waits until URL contains text.                       |
| `urlMatches(String regex)`                               | Waits until URL matches regex.                       |
| `refreshed(ExpectedCondition<T> condition)`              | Waits for condition to be true after a page refresh. |
| `javaScriptThrowsNoExceptions(String script)`            | Waits until JS runs without error.                   |
| `javaScriptResultEquals(String script, Object expected)` | Waits until JS result matches.                       |

---

=============================================================================================================================


declaration
use

1 conditional based it will work more efficient
2 finding element is inclusive(for some condition)
3 it will wait for conition to be true , then consider the time
4 we need to write multiple statement for multiple element
-----------------------------------------------------------------------------------------------------------
FLUENT WAIT DECLARATION

wait<Webdriver> mywait = new Fluentwait<Web driver>(driver).waitTimeout(Duration.ofsec(30)).pollingEvery(Duration.ofsec(5))
                                                                                           .ignoring(NosuchelementException.class);

WebElement txtUsername mywait.until(new Function<WebDriver, WebElement>() {

public WebElement apply(WebDriver driver) (return driver.findElement(By.xpath("//input[@placeholder

--------------------------------------------------------------------------------------------------------------------------------

NAVIGATION COMMANDS
---------------------

1 navigate().to(url)  ------------->   it accept both string format and  and object method format    or optional create
driver.navigate().to("url")
        or
url myurl = new url("url")  ---------> these is java package
driver.navigate().to(myurl)
        or
driver.get("https://letcode.in/edit/"); ------------->    it accept only in string format only


2 navigate().back()    <--
3 navigate().forward()  -->
4 navigate().refresh()

-----------------------------------------------------------------------------------------------------------------

getwindowhandle()
getwindowhandles()


driver.switchto().window(winid)

// approach 1 normal : switch to using LIST AND SET
// approach 2 looping method :

====================================================================================================================

Javascript Alerts

Alert myalert = driver.switchto().alert()

driver.switchTo().alert().accept();
driver.switchTo().alert().dismiss();
driver.switchTo().alert().getText();
driver.switchTo().alert().sendkeys("text");

Alert alert = mywait.until(ExpectedConditions.alertIsPresent());  by using explicit condition

Authentication popup :

http://username:password@the-internet.herokuapp.com/basic_auth   --- syntax

http://admin:admin@the-internet.herokuapp.com/basic_auth












